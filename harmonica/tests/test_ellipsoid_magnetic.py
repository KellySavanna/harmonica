# Copyright (c) 2018 The Harmonica Developers.
# Distributed under the terms of the BSD 3-Clause License.
# SPDX-License-Identifier: BSD-3-Clause
#
# This code is part of the Fatiando a Terra project (https://www.fatiando.org)
#
import numpy as np
import pytest
import verde as vd
from scipy.constants import mu_0

import harmonica as hm

from .._forward.create_ellipsoid import (
    OblateEllipsoid,
    ProlateEllipsoid,
    TriaxialEllipsoid,
)
from .._forward.ellipsoid_magnetics import (
    _depol_oblate_int,
    _depol_prolate_int,
    _depol_triaxial_int,
    ellipsoid_magnetics,
    get_magnetisation,
)
from .._forward.utils_ellipsoids import get_rotation_matrix


def sphere_magnetic(coordinates, radius, center, magnetization):
    """
    Compute the magnetic field generated by a sphere with uniform magnetization.

    The field inside the sphere is uniform. Outside the sphere it's equivalent
    to the dipole field.

    Parameters
    ----------
    coordinates : tuple of floats or arrays
        Coordinates of the observation points in the following order:
        easting, northing, upward.
    radius : float
        Radius of the sphere.
    center : tuple of floats
        Coordinates of the center of the sphere in the same order as the
        ``coordinates``.
    magnetization : tuple of floats
        Magnetization vector of the sphere.

    Returns
    -------
    be, bn, bu : arrays
        Three components of the magnetic field on the observation points in nT.
    """
    # Ravel the coordinates into 1d arrays
    cast = np.broadcast(*coordinates)
    easting, northing, upward = tuple(np.asarray(c).ravel() for c in coordinates)

    # Get the coordinates of the observation points in a coordinate system
    # located in the center of the sphere
    x, y, z = (easting - center[0], northing - center[1], upward - center[2])

    # Allocate arrays for the resulting magnetic field
    be, bn, bu = tuple(np.zeros(cast.size) for _ in range(3))

    # Compute the internal magnetic field in nT.
    magnetization = np.asarray(magnetization)
    inside = (x**2 + y**2 + z**2) <= radius**2
    be[inside] += 2 / 3 * mu_0 * magnetization[0] * 1e9
    bn[inside] += 2 / 3 * mu_0 * magnetization[1] * 1e9
    bu[inside] += 2 / 3 * mu_0 * magnetization[2] * 1e9

    # Compute the external magnetic field (a dipole field) in nT.
    # Get the magnetic moment of the equivalent dipole
    mag_moment = 4 / 3 * np.pi * radius**3 * magnetization
    be_out, bn_out, bu_out = hm.dipole_magnetic(
        (easting[~inside], northing[~inside], upward[~inside]),
        center,
        mag_moment,
        field="b",
    )
    be[~inside] = be_out
    bn[~inside] = bn_out
    bu[~inside] = bu_out

    be, bn, bu = tuple(b.reshape(cast.shape) for b in (be, bn, bu))
    return be, bn, bu


def get_sphere_magnetization(susceptibility, external_field):
    """
    Compute sphere's induced magnetization.

    Parameters
    ----------
    susceptibility : float or (3, 3) array
        Magnetic susceptibility of the sphere as a scalar or a tensor.
    external_field : tuple
        The uniform magnetic field B as a tuple with values of
        (magnitude, inclination, declination). The magnitude should be in nT.

    Returns
    -------
    magnetization : tuple
        Tuple with components of the magnetization vector in A/m.
    """
    # Get external field components
    b0_field = np.array(hm.magnetic_angles_to_vec(*external_field))
    h0_field = b0_field / mu_0 * 1e-9  # convert to T

    # Compute magnetization of the sphere accounting for demagnetization effect.
    if not isinstance(susceptibility, np.ndarray):
        susceptibility = susceptibility * np.identity(3)
    inv = np.linalg.inv(np.identity(3) + 1 / 3 * susceptibility)
    magnetization = susceptibility @ inv @ h0_field
    return magnetization


def test_likeness_to_sphere():
    """Using a, b, c as almost equal, compare how the close the ellipsoids
    match the dipole-sphere magnetic approximation for low susceptibilities.
    At higher susceptibilities, the self-demag will make the ellipsoid
    deviate."""

    # create field
    k_values = [0.01, 0.001, 0.0001]
    b0 = np.array(hm.magnetic_angles_to_vec(55_000, 0.0, 90.0))
    h0_am = np.array(b0 * 1e-9 / mu_0)
    m = [k * h0_am for k in k_values]

    # create coords
    easting = np.linspace(0, 2 * 60, 50)
    northing, upward = np.zeros_like(easting), np.zeros_like(easting)
    coordinates = tuple(np.atleast_2d(c) for c in (easting, northing, upward))

    # create ellipsoids
    pro_ellipsoid = ProlateEllipsoid(a=60, b=59.99, yaw=0, pitch=0, centre=(0, 0, 0))
    tri_ellipsoid = TriaxialEllipsoid(
        a=60, b=59.999, c=59.998, yaw=0, pitch=0, roll=0, centre=(0, 0, 0)
    )
    obl_ellipsoid = OblateEllipsoid(a=59.99, b=60, yaw=0, pitch=0, centre=(0, 0, 0))

    for indx, k in enumerate(k_values):
        # ellipsoids
        be_pro, _, _ = ellipsoid_magnetics(
            coordinates, pro_ellipsoid, k, (55_000, 0.0, 90.0), field="b"
        )
        be_pro = be_pro.ravel()
        be_tri, _, _ = ellipsoid_magnetics(
            coordinates, tri_ellipsoid, k, (55_000, 0.0, 90.0), field="b"
        )
        be_tri = be_tri.ravel()
        be_obl, _, _ = ellipsoid_magnetics(
            coordinates, obl_ellipsoid, k, (55_000, 0.0, 90.0), field="b"
        )
        be_obl = be_obl.ravel()

        # sphere
        b_e, b_n, b_u = sphere_magnetic(
            coordinates, radius=60, center=(0, 0, 0), magnetization=m[indx]
        )
        b_e = b_e.ravel()

        # test similarity
        np.testing.assert_allclose(be_pro, b_e, rtol=1e-2)

        np.testing.assert_allclose(be_tri, b_e, rtol=1e-2)

        np.testing.assert_allclose(be_obl, b_e, rtol=1e-2)


def test_euler_returns():
    """Check the euler returns are exact"""
    r0 = get_rotation_matrix(0, 0, 0)
    r360 = get_rotation_matrix(360, 0, 0)
    assert np.allclose(r0, r360)


def test_magnetic_symmetry():
    """
    Check the symmetry of magentic calculations at surfaces above and below
    the body.
    """
    a, b, c = (4, 3, 2)  # triaxial ellipsoid
    yaw, pitch, roll = (0, 0, 0)
    external_field = (10_000, 0, 0)
    susceptibility = 0.1
    triaxial_example = TriaxialEllipsoid(a, b, c, yaw, pitch, roll, (0, 0, 0))
    triaxial_example2 = TriaxialEllipsoid(a, b, c, yaw, pitch, roll, (0, 0, 0))

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    coordinates = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )
    coordinates2 = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=-5
    )

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        triaxial_example,
        susceptibility,
        external_field,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates2,
        triaxial_example2,
        susceptibility,
        external_field,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.flip(np.abs(be2)))
    np.testing.assert_allclose(np.abs(bn1), np.flip(np.abs(bn2)))
    np.testing.assert_allclose(np.abs(bu1), np.flip(np.abs(bu2)))


def test_flipped_h0():
    """
    Check that reversing the magentising field produces the same (reversed)
    field.
    """

    a, b = (2, 4)  # triaxial ellipsoid
    yaw, pitch = 0, 0

    external_field1 = np.array((55_000, 0.0, 90.0))
    external_field2 = -external_field1
    susceptibility = 0.1
    oblate_example = OblateEllipsoid(a, b, yaw, pitch, (0, 0, 0))

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    coordinates = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        oblate_example,
        susceptibility,
        external_field1,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates,
        oblate_example,
        susceptibility,
        external_field2,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.abs(be2))
    np.testing.assert_allclose(np.abs(bn1), np.abs(bn2))
    np.testing.assert_allclose(np.abs(bu1), np.abs(bu2))


def test_zero_susceptibility():
    """
    Test for the case of 0 susceptibility == inducing field.
    """

    a, b = 1, 2
    susceptibility = 0
    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    coordinates = vd.grid_coordinates(
        region=(-10, 10, -10, 10), spacing=1.0, extra_coords=5
    )
    h0 = hm.magnetic_angles_to_vec(55_000, 0.0, 90.0)

    be, bn, bu = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, h0, field="b"
    )

    np.testing.assert_allclose(be[0], 0)
    np.testing.assert_allclose(bn[0], 0)
    np.testing.assert_allclose(bu[0], 0)


def test_zero_field():
    """
    Test that zero field produces zero anomalies.
    """

    a, b = 1, 2
    external_field = np.array([0, 0, 0])
    susceptibility = 0.01

    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    coordinates = vd.grid_coordinates(
        region=(-10, 10, -10, 10), spacing=1.0, extra_coords=5
    )

    be, bn, bu = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, external_field, field="b"
    )

    np.testing.assert_allclose(be[0], 0)
    np.testing.assert_allclose(bn[0], 0)
    np.testing.assert_allclose(bu[0], 0)


def test_mag_ext_int_boundary():
    """
    Check the boundary between internal and external field calculations is
    consistent.
    """

    a, b = 50, 60
    external_field = (55_000, 0.0, 90.0)
    susceptibility = 0.01

    ellipsoid = OblateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))

    e = np.array([49.99, 50.00])
    n = np.array([0.0, 0.0])
    u = np.array([0.0, 0.0])
    coordinates = (e, n, u)

    be, bn, bu = ellipsoid_magnetics(
        coordinates, ellipsoid, susceptibility, external_field, field="b"
    )

    # ideally the tolerances are lower for these - issue created
    np.testing.assert_allclose(be[0], be[1], rtol=1e-4)


def test_mag_flipped_ellipsoid():
    """
    Check that rotating the ellipsoid in various ways maintains expected
    results.

    """
    a, b, c = (4, 3, 2)
    external_field = (10_000, 0, 0)
    susceptibility = 0.01

    triaxial_example = TriaxialEllipsoid(
        a, b, c, yaw=0, pitch=0, roll=0, centre=(0, 0, 0)
    )
    triaxial_example2 = TriaxialEllipsoid(
        a, b, c, yaw=180, pitch=180, roll=180, centre=(0, 0, 0)
    )

    # define observation points (2D grid) at surface height (z axis,
    # 'Upward') = 5
    x, y, z = vd.grid_coordinates(
        region=(-20, 20, -20, 20), spacing=0.5, extra_coords=5
    )

    # ignore internal field as this won't be 'flipped' in the same natr
    internal_mask = ((x**2) / (a**2) + (y**2) / (b**2) + (z**2) / (c**2)) < 1
    coordinates = tuple(c[internal_mask] for c in (x, y, z))

    be1, bn1, bu1 = ellipsoid_magnetics(
        coordinates,
        triaxial_example,
        susceptibility,
        external_field,
        field="b",
    )
    be2, bn2, bu2 = ellipsoid_magnetics(
        coordinates,
        triaxial_example2,
        susceptibility,
        external_field,
        field="b",
    )

    np.testing.assert_allclose(np.abs(be1), np.abs(be2))
    np.testing.assert_allclose(np.abs(bn1), np.abs(bn2))
    np.testing.assert_allclose(np.abs(bu1), np.abs(bu2))


def test_euler_rotation_symmetry_mag():
    """
    Check thoroughly that euler rotations (e.g. 180 or 360 rotations) produce
    the expected result.
    """

    a, b, c = 5, 4, 3
    external_field = (55_000, 0.0, 90.0)
    susceptibility = 0.01
    coordinates = x, y, z = vd.grid_coordinates(
        region=(-5, 5, -5, 5), spacing=1.0, extra_coords=5
    )
    internal_mask = ((x**2) / (a**2) + (y**2) / (b**2) + (z**2) / (c**2)) < 1
    coordinates = tuple(c[internal_mask] for c in (x, y, z))

    def check_rotation_equivalence(base_ellipsoid, rotated_ellipsoids):
        base_be, base_bn, base_bu = ellipsoid_magnetics(
            coordinates, base_ellipsoid, susceptibility, external_field
        )
        for rotated in rotated_ellipsoids:
            be, bn, bu = ellipsoid_magnetics(
                coordinates, rotated, susceptibility, external_field
            )
            np.testing.assert_allclose(np.abs(be), np.abs(base_be), rtol=1e-4)
            np.testing.assert_allclose(np.abs(bn), np.abs(base_bn), rtol=1e-4)
            np.testing.assert_allclose(np.abs(bu), np.abs(base_bu), rtol=1e-4)

    # triaxial cases
    base_tri = TriaxialEllipsoid(a, b, c, yaw=0, pitch=0, roll=0, centre=(0, 0, 0))
    tri_rotated = [
        TriaxialEllipsoid(a, b, c, yaw=360, pitch=0, roll=0, centre=(0, 0, 0)),
        TriaxialEllipsoid(a, b, c, yaw=0, pitch=180, roll=0, centre=(0, 0, 0)),
        TriaxialEllipsoid(a, b, c, yaw=0, pitch=360, roll=360, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_tri, tri_rotated)

    # prolate cases
    base_pro = ProlateEllipsoid(a, b, yaw=0, pitch=0, centre=(0, 0, 0))
    pro_rotated = [
        ProlateEllipsoid(a, b, yaw=360, pitch=0, centre=(0, 0, 0)),
        ProlateEllipsoid(a, b, yaw=0, pitch=180, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_pro, pro_rotated)

    # oblate cases
    base_obl = OblateEllipsoid(b, a, yaw=0, pitch=0, centre=(0, 0, 0))
    obl_rotated = [
        OblateEllipsoid(b, a, yaw=360, pitch=0, centre=(0, 0, 0)),
        OblateEllipsoid(b, a, yaw=0, pitch=180, centre=(0, 0, 0)),
    ]
    check_rotation_equivalence(base_obl, obl_rotated)


def test_internal_depol_equals_1():
    """Test that the internal depol tensor component sum equals 1"""

    onxx, onyy, onzz = _depol_oblate_int(3, 5)
    np.testing.assert_allclose((onxx + onyy + onzz), 1)

    pnxx, pnyy, pnzz = _depol_prolate_int(5, 3)
    np.testing.assert_allclose((pnxx + pnyy + pnzz), 1)

    tnxx, tnyy, tnzz = _depol_triaxial_int(5, 4, 3)
    np.testing.assert_allclose((tnxx + tnyy + tnzz), 1)


class TestDemagnetizationEffects:
    """
    Test the ``_get_magnetisation`` function.
    """

    @pytest.fixture(params=("oblate", "prolate", "triaxial"))
    def ellipsoid_semiaxes(self, request):
        ellipsoid_type = request.param
        if ellipsoid_type == "oblate":
            a, b = 50.0, 60.0
            c = b
        elif ellipsoid_type == "prolate":
            a, b = 60.0, 50.0
            c = b
        elif ellipsoid_type == "triaxial":
            a, b, c = 70.0, 60.0, 50.0
        else:
            raise ValueError()
        return a, b, c

    def test_demagnetization(self, ellipsoid_semiaxes):
        """
        Test demagnetization effects in ``get_magnetization``.

        The magnetization accounting with demagnetization should have a smaller
        magnitude than the magnetization without considering it.
        """
        h0_field = np.array([55_000.0, 10_000.0, -2_000.0])

        a, b, c = ellipsoid_semiaxes
        susceptibility = 0.5
        susceptibility_tensor = susceptibility * np.identity(3)

        # Compute magnetization considering demagnetization effect
        rem_mag = (0, 0, 0)
        magnetization = get_magnetisation(
            a, b, c, susceptibility_tensor, h0_field, rem_mag
        )

        # Compute magnetization without considering demagnetization effect
        magnetization_no_demag = susceptibility * h0_field

        # Check that the former is smaller than the latter
        assert (magnetization**2).sum() < (magnetization_no_demag**2).sum()


@pytest.mark.parametrize(
    ("ellipsoid_type", "a", "b", "c"),
    [
        ("oblate", 50.0, 60.0, 60.0),
        ("prolate", 60.0, 50.0, 50.0),
        ("triaxial", 70.0, 60.0, 50.0),
    ],
)
def test_internal_demagnetization_components(ellipsoid_type, a, b, c):
    r"""
    Test if demagnetization tensors inside the ellipsoids have all positive values.

    This guarantees that the code implements the appropriate sign convention for the
    demagnetization tensor :math:`\mathbf{N}`, defined as:

    .. math::

        \mathbf{H}(\mathbf{r}) = \mathbf{H}_0 - \mathbf{N}(\mathbf{r}) \mathbf{M}
    """
    if ellipsoid_type == "oblate":
        n_components = _depol_oblate_int(a, b)
    elif ellipsoid_type == "prolate":
        n_components = _depol_prolate_int(a, b)
    elif ellipsoid_type == "triaxial":
        n_components = _depol_triaxial_int(a, b, c)
    else:
        raise ValueError()

    # check that all diagonal elements are positive
    assert all(n > 0 for n in n_components)


class TestMagnetizationVersusSphere:
    """
    Test if ellipsoid's magnetization approximates the one of the sphere.
    """

    @pytest.fixture
    def radius(self):
        """
        Sphere radius.
        """
        return 50.0

    @pytest.fixture(params=("oblate", "prolate", "triaxial"))
    def ellipsoid_semiaxes(self, radius, request):
        """
        Ellipsoid's semiaxes that approximate a sphere.
        """
        a = radius
        ellipsoid_type = request.param
        if ellipsoid_type == "oblate":
            b = c = a + 1e-2
        elif ellipsoid_type == "prolate":
            b = c = a - 1e-2
        elif ellipsoid_type == "triaxial":
            b = a - 1e-3
            c = a - 1e-2
        else:
            raise ValueError()
        return a, b, c

    def test_magnetization_vs_sphere(self, ellipsoid_semiaxes):
        """
        Test if ellipsoid's magnetization approximates the one of the sphere.
        """
        # Define moderately high susceptibility to account for demagnetization effects
        susceptibility = 0.5

        # Define arbitrary external field
        intensity, inclination, declination = 55_321, 70.2, -12.3
        b0_field = np.array(
            hm.magnetic_angles_to_vec(intensity, inclination, declination)
        )
        h0_field = b0_field / mu_0 * 1e-9  # convert to T

        # Compute magnetizations
        a, b, c = ellipsoid_semiaxes
        k_matrix = susceptibility * np.identity(3)
        rem_mag = (0, 0, 0)
        magnetization_ellipsoid = get_magnetisation(
            a, b, c, k_matrix, h0_field, rem_mag
        )
        magnetization_sphere = get_sphere_magnetization(
            susceptibility, (intensity, inclination, declination)
        )

        # Compare magnetization of the sphere vs magnetization of the ellipsoid
        rtol = 1e-4
        np.testing.assert_allclose(
            magnetization_ellipsoid, magnetization_sphere, rtol=rtol
        )


class TestMagneticFieldVersusSphere:
    """
    Test if magnetic field of ellipsoid approximates the one of the sphere.
    """

    # Sphere radius, center, and susceptibility.
    radius = 50.0
    center = (0, 0, 0)
    susceptibility = 0.5

    # Difference between ellipsoid's semiaxes.
    # It should be small compared to the sphere radius, so the ellipsoid approximates
    # a sphere.
    delta = 0.001

    # Define external field
    external_field = (55_123.0, 32.0, -28.9)

    @pytest.fixture(params=[0.0, 100.0], ids=["height=0", "height=100"])
    def coordinates(self, request):
        """Sample coordinates of observation points."""
        region = (-200, 200, -200, 200)
        shape = (151, 151)
        height = request.param
        coordinates = vd.grid_coordinates(region, shape=shape, extra_coords=height)
        return coordinates

    @pytest.fixture
    def sphere_magnetic_field(self, coordinates):
        """Magnetic field of sphere on observation points."""
        magnetization = get_sphere_magnetization(
            self.susceptibility, self.external_field
        )
        b_sphere = sphere_magnetic(coordinates, self.radius, self.center, magnetization)
        return b_sphere

    def get_ellipsoid(self, ellipsoid_type: str):
        """
        Return ellipsoid that approximates a sphere.

        Parameters
        ----------
        ellipsoid_type : {"oblate", "prolate", "triaxial"}
            Type of ellipsoid.

        Returns
        -------
        OblateEllipsoid, ProlateEllipsoid or TriaxialEllipsoid
        """
        yaw, pitch, roll = 0, 0, 0
        a = self.radius
        if ellipsoid_type == "oblate":
            ellipsoid = OblateEllipsoid(
                a=a,
                b=a + self.delta,
                yaw=yaw,
                pitch=pitch,
                centre=self.center,
            )
        elif ellipsoid_type == "prolate":
            ellipsoid = ProlateEllipsoid(
                a=a,
                b=a - self.delta,
                yaw=yaw,
                pitch=pitch,
                centre=self.center,
            )
        elif ellipsoid_type == "triaxial":
            ellipsoid = TriaxialEllipsoid(
                a=a,
                b=a - self.delta,
                c=a - 2 * self.delta,
                yaw=yaw,
                pitch=pitch,
                roll=roll,
                centre=self.center,
            )
        else:
            raise ValueError()
        return ellipsoid

    @pytest.mark.parametrize("ellipsoid_type", ["oblate", "prolate", "triaxial"])
    def test_magnetic_field_vs_sphere(
        self, coordinates, sphere_magnetic_field, ellipsoid_type
    ):
        """
        Test magnetic field of ellipsoids against the one for a sphere.
        """
        b_e_sphere, b_n_sphere, b_u_sphere = sphere_magnetic_field
        ellipsoid = self.get_ellipsoid(ellipsoid_type)
        b_e, b_n, b_u = ellipsoid_magnetics(
            coordinates, ellipsoid, self.susceptibility, self.external_field, field="b"
        )
        maxabs = np.max([np.abs(b_e_sphere), np.abs(b_n_sphere), np.abs(b_u_sphere)])
        atol = maxabs * 0.01
        rtol = 1e-4
        np.testing.assert_allclose(b_e_sphere, b_e, atol=atol, rtol=rtol)
        np.testing.assert_allclose(b_n_sphere, b_n, atol=atol, rtol=rtol)
        np.testing.assert_allclose(b_u_sphere, b_u, atol=atol, rtol=rtol)
